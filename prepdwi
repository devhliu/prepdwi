#!/bin/bash

function die {
 echo $1 >&2
 exit 1
}

function fixsubj {
#add on sub- if not exists
subj=$1
 if [ ! "${subj:0:4}" = "sub-" ]
 then
  subj="sub-$subj"
 fi
 echo $subj
}

function fixsess {
#add on ses- if not exists
sess=$1
 if [ ! "${sess:0:4}" = "ses-" ]
 then
  sess="sub-$sess"
 fi
 echo $sess
}



execpath=`dirname $0`
execpath=`realpath $execpath`

in_atlas_dir=$execpath/atlases

matching_dwi=
participant_label=
notopup=0
nodke=0
bedpost=1
matching_T1w=
n_cpus=8
reg_init_subj=
grad_coeff_file=
scratch_dir=
noregT1=0

#default:
atlas=dosenbach

atlas_space=MNI152_1mm
#atlas_label_nii=dosenbach/dos160_roi_atlas.nii.gz
#atlas_label_csv=dosenbach/dos160_roi_atlas.csv

nprobseeds=5000

if [ "$#" -lt 3 ]
then
 echo "Usage: prepdwi bids_dir output_dir {participant,group,participant2} <optional arguments>"
 echo "          [--participant_label PARTICIPANT_LABEL [PARTICIPANT_LABEL...]]"
 echo "          [--matching_dwi MATCHING_PATTERN]"
 echo "          [--matching_T1w MATCHING_STRING]"
 echo "          [--reg_init_participant PARTICIPANT_LABEL]"
 echo "          [--grad_coeff_file GRAD_COEFF_FILE]"
 echo "          [-w WORK_DIR]  (scratch directory)"
 echo ""
 echo "          [--no-regT1]"
 echo "          [--no-topup]"
 echo "          [--no-bedpost]"
 echo "          [--no-dke]"
 echo "          [--n_cpus NCPUS] (for bedpost, default: 8) "
 echo ""
 echo " participant2 (probtrack connectivity) options:"
 echo "          [--nprobseeds] N (for probtrackx, default: 5000) "
 echo "      Choose built-in atlas:"
 echo "          [--atlas NAME (default: dosenbach)"
 echo ""
 echo "       Available built-in atlas labels/csv:"
 pushd $execpath/cfg > /dev/null
echo -n "          "; 
ls *
popd > /dev/null
 echo "   "
 echo "       Customize atlas labels:"
 echo "          {--atlas_space NAME (MNI152_1mm or MNI152NLin2009cAsym)"
 echo "          [--atlas_label_nii NIFTI" 
 echo "          [--atlas_label_csv LABEL_INDEX_CSV"
 echo ""

 exit 1
fi


#=====================================================================
#---------------------  ARGUMENT PARSING -----------------------------
#=====================================================================

in_bids=$1 
out_folder=$2 
analysis_level=$3


shift 3

while :; do
      case $1 in
     -h|-\?|--help)
	     usage
            exit
              ;;
    --no-regT1 )
	noregT1=1;;
     --no-topup )
	notopup=1;;
     --no-bedpost )
	bedpost=0;;
     --no-dke )
	nodke=1;;
     --n_cpus )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                n_cpus=$2
                  shift
	      else
              die 'error: "--n_cpus" requires a non-empty option argument.'
            fi
              ;;
     -w )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                scratch_dir=$2
                  shift
	      else
              die 'error: "-w" requires a non-empty option argument.'
            fi
              ;;
     --participant_label )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                participant_label=$2
                  shift
	      else
              die 'error: "--participant" requires a non-empty option argument.'
            fi
              ;;
     --participant_label=?*)
          participant_label=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --participant_label=)         # handle the case of an empty --participant=
         die 'error: "--participant_label" requires a non-empty option argument.'
          ;;
     --matching_dwi )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matching_dwi=$2
                  shift
	      else
              die 'error: "--matching_dwi" requires a non-empty option argument.'
            fi
              ;;
     --matching_dwi=?*)
          matching_dwi=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matching_dwi=)         # handle the case of an empty --acq=
         die 'error: "--matching_dwi" requires a non-empty option argument.'
          ;;
     --matching_T1w )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matching_T1w=$2
                  shift
	      else
              die 'error: "--matching_T1w" requires a non-empty option argument.'
            fi
              ;;
     --matching_T1w=?*)
          matching_T1w=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matching_T1w=)         # handle the case of an empty --acq=
         die 'error: "--matching_dwi" requires a non-empty option argument.'
          ;;


      --reg_init_participant )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                reg_init_subj=$2
                  shift
	      else
              die 'error: "--reg_init_participant" requires a non-empty option argument.'
            fi
              ;;
     --reg_init_participant=?*)
          reg_init_subj=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --reg_init_participant=)         # handle the case of an empty --participant=
         die 'error: "--reg_init_participant" requires a non-empty option argument.'
          ;;


       --grad_coeff_file )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                grad_coeff_file=$2
                  shift
	      else
              die 'error: "--grad_coeff_file" requires a non-empty option argument.'
            fi
              ;;
     --grad_coeff_file=?*)
          grad_coeff_file=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --grad_coeff_file=)         # handle the case of an empty --participant=
         die 'error: "--grad_coeff_file" requires a non-empty option argument.'
          ;;


     
      
      --atlas )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas=$2
                  shift
	      else
              die 'error: "--atlas" requires a non-empty option argument.'
            fi
              ;;
     --atlas=?*)
          atlas=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas=)         # handle the case of an empty --participant=
         die 'error: "--atlas" requires a non-empty option argument.'
          ;;


      
      --atlas_label_nii )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas_label_nii=$2
                  shift
	      else
              die 'error: "--atlas_label_nii" requires a non-empty option argument.'
            fi
              ;;
     --atlas_label_nii=?*)
          atlas_label_nii=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas_label_nii=)         # handle the case of an empty --participant=
         die 'error: "--atlas_label_nii" requires a non-empty option argument.'
          ;;


      --atlas_label_csv )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas_label_csv=$2
                  shift
	      else
              die 'error: "--atlas_label_csv" requires a non-empty option argument.'
            fi
              ;;
     --atlas_label_csv=?*)
          atlas_label_csv=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas_label_csv=)         # handle the case of an empty --participant=
         die 'error: "--atlas_label_csv" requires a non-empty option argument.'
          ;;


      --atlas_space )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                atlas_space=$2
                  shift
	      else
              die 'error: "--atlas_space" requires a non-empty option argument.'
            fi
              ;;
     --atlas_space=?*)
          atlas_space=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --atlas_space=)         # handle the case of an empty --participant=
         die 'error: "--atlas_space" requires a non-empty option argument.'
          ;;

     --nprobseeds )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                nprobseeds=$2
                  shift
	      else
              die 'error: "--nprobseeds" requires a non-empty option argument.'
            fi
              ;;


      -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
              ;;
     *)               # Default case: No more options, so break out of the loop.
          break
    esac
  
 shift
  done


shift $((OPTIND-1))

#=====================================================================
#--------------------- SET-UP VARIABLES  -----------------------------
#=====================================================================

echo matching_dwi=$matching_dwi
echo participant_label=$participant_label

if [ -e $in_bids ]
then
	in_bids=`realpath $in_bids`
else
	echo "ERROR: bids_dir $in_bids does not exist!"
	exit 1
fi

if [ -n "$grad_coeff_file" ]
then
        if [ -e $grad_coeff_file ]
        then
            grad_coeff_file=`realpath $grad_coeff_file`
            if [ "$noregT1" = "1" ]
            then
            final_suffix=_gradCorr
            else
            final_suffix=_regT1_gradCorr
            fi
        do_gradcorr=1
        else
            echo "grad_coeff_file $grad_coeff_file does not exist! exiting!"
            exit 1
        fi

else
    if [ "$noregT1" = "1" ]
    then
    final_suffix=
    else
    final_suffix=_regT1
    fi
    do_gradcorr=0
fi


#exports for scripts to make use of
export scratch_dir



dwi_prefix=uncorrected

participants=$in_bids/participants.tsv

work_folder=$out_folder/work
derivatives=$out_folder #bids derivatives

mkdir -p $work_folder $derivatives
derivatives=`realpath $derivatives`

#just in case participants.tsv does not exist:
if [ ! -e $participants ]
then
    #participants tsv not required by bids, so if it doesn't exist, create one for temporary use
    participants=$work_folder/participants.tsv
    echo participant_id > $participants
    participants=`realpath $participants`
    pushd $in_bids
    ls -d sub-* >> $participants
    popd 
fi



if [ -n "$participant_label" ]
then
subjlist=`echo $participant_label | sed  's/,/\ /g'` 
else
subjlist=`tail -n +2 $participants | awk '{print $1}'`
fi

if [ -e $execpath/cfg/$atlas ]
then
  source $execpath/cfg/$atlas
  else
   echo "atlas config file $execpath/cfg/$atlas does not exist!"
   exit 1
fi
#=====================================================================
#--------------------- BEGIN STAGE:  participant  --------------------
#=====================================================================

if [ "$analysis_level" = "participant" ]
then
 echo " running participant level analysis"


pushd $work_folder
echo $participants

if [ -n "$matching_dwi" ]
then
  searchstring_dwi=\*${matching_dwi}\*dwi.nii*
else
  searchstring_dwi=*dwi.nii*
fi

if [ -n "$matching_T1w" ]
then
  searchstring_t1w=\*${matching_T1w}\*T1w.nii*
else
  searchstring_t1w=*T1w.nii*
fi



#copy atlases to output folder, and run registration for all of them
for atlas_dir in `ls -d $in_atlas_dir/*`
do
 atlas_name=${atlas_dir##*/}

 if [ ! -e $atlas_name ]
 then
# iscopying=iscopying_${atlas_name}
 #mkdir to ensure only one process copies the files..
 if $(mkdir -p $atlas_name )
 then
 #  mkdir -p $atlas_name
   cp -Rv $atlas_dir/* $atlas_name
 #  rmdir $iscopying
 else
   sleep 30 #wait for 1st job to finish copying
 fi
 fi
done



t1_img_type=t1/t1.brain.inorm.nii.gz

for subj in $subjlist 
do

    #add on sub- if not exists
    subj=`fixsubj $subj`

    #loop over sub- and sub-/ses-
    for subjfolder in `ls -d $in_bids/$subj/dwi $in_bids/$subj/ses-*/dwi`
    do

        subj_sess_dir=${subjfolder%/dwi}
        subj_sess_dir=${subj_sess_dir##$in_bids/}
        sess=${subj_sess_dir##*/}
        subj_sess_prefix=${subj}_${sess}
        echo subjfolder $subjfolder
        echo subj_sess_dir $subj_sess_dir
        echo sess $sess
        echo subj_sess_prefix $subj_sess_prefix


N_t1w=`eval ls $in_bids/$subj_sess_dir/anat/${subj_sess_prefix}${searchstring_t1w} | wc -l`
in_t1w=`eval ls $in_bids/$subj_sess_dir/anat/${subj_sess_prefix}${searchstring_t1w} | head -n 1`

if [ ! -e $subj_sess_prefix/t1/t1.nii.gz ]
then
echo --- Running importT1 ---
echo Found $N_t1w matching T1w, using first found: $in_t1w
echo $execpath/bin/importT1 $in_t1w $subj_sess_prefix
$execpath/bin/importT1 $in_t1w $subj_sess_prefix
else
echo --- Skipping importT1 ---
fi

if [ ! -e $subj_sess_prefix/${t1_img_type} ]
then
echo --- Running preprocT1 ---
echo $execpath/bin/preprocT1 $subj_sess_prefix
 $execpath/bin/preprocT1 $subj_sess_prefix
 else
echo --- Skipping preprocT1 ---
fi


#register t1 to atlases
for atlas_dir in `ls -d $in_atlas_dir/*`
do
 atlas_name=${atlas_dir##*/}


#TODO: need to convert reg_init_subj to subj_sess

if [ -n "$reg_init_subj" ]
then
 echo --- Running atlas affine registration initialized with $reg_init_subj xfm ---
 echo $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix -i $reg_init_subj
 $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix -i $reg_init_subj
 echo --- Running atlas b-spline registration ---
 echo $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix
 $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix

 else
     
 if [ ! -e $subj_sess_prefix/reg/affine_aladin_t1/${atlas_name}_$subj_sess_prefix/${atlas_name}_to_${subj_sess_prefix}.xfm ]
 then
 echo --- Running atlas affine registration ---
 echo $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix 
 $execpath/bin/reg_intersubj_aladin  t1 $t1_img_type $atlas_name $subj_sess_prefix 
 else 
 echo --- Skipping atlas affine registration ---
 fi

 if [ ! -e $subj_sess_prefix/reg/bspline_f3d_t1/${atlas_name}_$subj_sess_prefix/ctrlpt_${atlas_name}_to_${subj_sess_prefix}.nii.gz ]
 then
    echo --- Running atlas b-spline registration ---
    echo $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix
    $execpath/bin/reg_bspline_f3d t1 $t1_img_type $atlas_name $subj_sess_prefix
 else 
  echo --- Skipping atlas b-spline registration ---

 fi


 fi # if [ -n "$reg_init_subj" ]





done #atlas_dir


#only proceed with pre-processing if preproc dwi does not exist
#preproc_dwi=`ls $subj/dwi/uncorrected_*${final_suffix}/dwi.nii.gz | tail -n 1`
#echo returnval $?
#echo before preproc
#if [ ! -e $preproc_dwi ]
#then
#echo about to preproc

Ndwi=`eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi} | wc -l`

 if [ ! -e $subj_sess_prefix/dwi/uncorrected/dwi_$Ndwi.nii.gz ]
 then
echo "--- Running importDWI ---"
 echo Ndwi=$Ndwi
echo Found $Ndwi matching dwi, using all: 
 eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi}

 echo "$execpath/bin/importDWI ${dwi_prefix} $Ndwi `eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi}` $subj_sess_prefix"
 $execpath/bin/importDWI ${dwi_prefix} $Ndwi `eval ls $in_bids/$subj_sess_dir/dwi/${subj_sess_prefix}${searchstring_dwi}` $subj_sess_prefix
else

echo "--- Skipping importDWI ---"
 fi

 if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise/dwi_$Ndwi.nii.gz ]
 then
echo "--- Running processDwiDenoise ---"
 echo $execpath/bin/processDwiDenoise uncorrected $subj_sess_prefix
 $execpath/bin/processDwiDenoise uncorrected $subj_sess_prefix
 else

echo "--- Skipping processDwiDenoise ---"
 fi

 if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring/dwi_$Ndwi.nii.gz ]
 then
echo "--- Running processUnring ---"
 echo $execpath/bin/processUnring uncorrected_denoise $subj_sess_prefix
 $execpath/bin/processUnring uncorrected_denoise $subj_sess_prefix

 else
     echo "--- Skipping processUnring ---"
 fi


 if [ "$notopup" = 1 -o "$Ndwi" = "1" ] 
 then
 
  if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_eddy/dwi.nii.gz ]
  then
echo "--- Running processEddyNoTopUp ---"
   echo $execpath/bin/processEddyNoTopUp uncorrected_denoise_unring $subj_sess_prefix
   $execpath/bin/processEddyNoTopUp uncorrected_denoise_unring $subj_sess_prefix
   else
echo "--- Skipping processEddyNoTopUp ---"
  fi
   eddy=eddy

  #at this stage, can do non-linear distortion correction (fieldmap-free), by registration to T1
  if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_eddy_dc/dwi.nii.gz ]
  then
   echo "--- Running processDistortCorrect ---"
   echo $execpath/bin/processDistortCorrect uncorrected_denoise_unring_eddy $subj_sess_prefix
   $execpath/bin/processDistortCorrect uncorrected_denoise_unring_eddy $subj_sess_prefix
 else
   echo "--- Skipping processDistortCorrect ---"
   fi

  if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_topup/dwi.nii.gz ]
  then 
echo "--- Running processTopUp ---"
    echo $execpath/bin/processTopUp uncorrected_denoise_unring $subj_sess_prefix
    $execpath/bin/processTopUp uncorrected_denoise_unring $subj_sess_prefix
else
echo "--- Skipping processTopUp ---"
  fi

  if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_topup_eddy/dwi.nii.gz ]
  then
echo "--- Running processEddy ---"
    echo $execpath/bin/processEddy uncorrected_denoise_unring_topup $subj_sess_prefix
    $execpath/bin/processEddy uncorrected_denoise_unring_topup $subj_sess_prefix

    else
        echo "--- Skipping processEddy ---"
  fi
  eddy=topup_eddy
 fi

 if [ "$noregT1" = "0" ]
 then

  if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}_regT1/dwi.nii.gz ]
  then
echo "--- Running processRegT1 ---"
  echo $execpath/bin/processRegT1 uncorrected_denoise_unring_$eddy $subj_sess_prefix
  $execpath/bin/processRegT1 uncorrected_denoise_unring_$eddy $subj_sess_prefix
else
    echo "--- Skipping processRegT1 ---"
  fi

  else 
      echo "--- Skipping processRegT1 (--no-regT1) ---"
  fi


  if [ $do_gradcorr = 1  ]
  then

      if [ "$noregT1" = "0" ]
      then

   if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}_regT1_gradCorr/dwi.nii.gz ]
   then
echo "--- Running processGradUnwarp ---"
  echo $execpath/bin/processGradUnwarp uncorrected_denoise_unring_$eddy $grad_coeff_file $subj_sess_prefix
  $execpath/bin/processGradUnwarp uncorrected_denoise_unring_$eddy $grad_coeff_file $subj_sess_prefix
  else 
echo "--- Skipping processGradUnwarp ---"
  fi
    else


   if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}_gradCorr/dwi.nii.gz ]
   then
    echo "--- Running processGradUnwarp ---"
      echo $execpath/bin/processGradUnwarp uncorrected_denoise_unring_$eddy $grad_coeff_file $subj_sess_prefix
      $execpath/bin/processGradUnwarp uncorrected_denoise_unring_$eddy $grad_coeff_file $subj_sess_prefix
      else 
    echo "--- Skipping processGradUnwarp ---"
      fi



    fi


  fi


  #else #if preproc dwi exists

 #if exists already, just need to set eddy to the proper value
 if [ -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_eddy${final_suffix}/dwi.nii.gz ]
 then
	 eddy=eddy
 else
	 eddy=topup_eddy
 fi
	

  
 # fi #if not exist preproc dwi


  #check if multi-shell
  bval=$subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}${final_suffix}/dwi.bval
  shells=$subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}${final_suffix}/dwi.shells
 if [ ! -e $shells ]
 then
  echo "Checking number of shells..."
  echo octave --path $execpath/octave --eval "writeShellsFromBval('$bval','$shells')"
  octave --path $execpath/octave --eval "writeShellsFromBval('$bval','$shells')"
 fi

  nshells=`cat $shells | wc -l`
  if [ "$nshells" -gt 1 ]
  then
      echo "--- Multi-shell DWI detected ---"
       is_multishell=1
       cat $shells
   else
      echo "--- Single-shell DWI detected ---"
       is_multishell=0
  fi

  #continue running pipelines
  if [ "$bedpost" = 1 ]
  then 
    if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}${final_suffix}/bedpost.bedpostX/dyads1.nii.gz ]
    then
echo "--- Running processBedpost ---"
    echo $execpath/bin/processBedpost $n_cpus uncorrected_denoise_unring_${eddy}${final_suffix} $subj_sess_prefix
    $execpath/bin/processBedpost $n_cpus uncorrected_denoise_unring_${eddy}${final_suffix} $subj_sess_prefix
    else
        echo "--- Skipping processBedpost ---"
    fi
    else
        echo "--- Skipping processBedpost (--no-bedpost) ---"
  fi 


  if [ "$is_multishell" = 1 ]
  then 

    
      if [ "$nodke" = "0" ]
    then
      if [ ! -e $subj_sess_prefix/dwi/uncorrected_denoise_unring_${eddy}${final_suffix}_dke/kmean.nii.gz ]
    then
echo "--- Running processDKE ---"
    echo $execpath/bin/processDKE uncorrected_denoise_unring_${eddy}${final_suffix} $subj_sess_prefix
    $execpath/bin/processDKE uncorrected_denoise_unring_${eddy}${final_suffix} $subj_sess_prefix
    else
        echo "--- Skipping processDKE ---"
    fi
    else

        echo "--- Skipping processDKE (--no-dke) ---"
    fi
  fi 

  #internally checks if files already exist before copying
echo "--- Running processCleanupBIDS ---"
  echo $execpath/bin/processCleanupBIDS uncorrected_denoise_unring_${eddy}${final_suffix} $derivatives $subj_sess_prefix
  $execpath/bin/processCleanupBIDS uncorrected_denoise_unring_${eddy}${final_suffix} $derivatives $subj_sess_prefix

done #loop over subj/sess

done #loop over subj


popd

#=====================================================================
#---------------------- END STAGE:  participant  ---------------------
#=====================================================================


#=====================================================================
#---------------------- BEGIN STAGE:  group ---- ---------------------
#=====================================================================

elif [ "$analysis_level" = "group" ]
 then

    echo "generating preproc QC reports"
    #TODO: move this to a separate script

    #need to make a subjlist for this command 

    #TODO:  use GNU parallel here:

    for subj in $subjlist
    do
        subj=`fixsubj $subj`
 
    #loop over sub- and sub-/ses-
    for subjfolder in `ls $in_bids/$subj/dwi $in_bids/$subj/ses-*/dwi`
    do

        subj_sess_dir=${subjfolder%/dwi}
        sess=${subj_sess_dir##*/}
        subj_sess_prefix=${subj}_${sess}

       
    pushd $work_folder
    $execpath/bin/genOverlay_brainmask $subj_sess_prefix > /dev/null
    $execpath/bin/genOverlay_mask  dwi/uncorrected_*_eddy/dwi.nii.gz dwi/uncorrected_*_eddy/brainmask.nii.gz dwi_brainmask $subj_sess_prefix > /dev/null

    for atlas_dir in `ls -d $in_atlas_dir/*`
    do
     atlas_name=${atlas_dir##*/}
     $execpath/bin/genOverlay_affine_atlasReg $atlas_name $subj_sess_prefix > /dev/null
     $execpath/bin/genOverlay_bspline_atlasReg $atlas_name $subj_sess_prefix > /dev/null
    done

    #dwi and T1 reg
    $execpath/bin/genOverlay_mask  dwi/uncorrected_*_regT1/dwi.nii.gz dwi/uncorrected_*_regT1/epi_reg/t1_diffres.nii.gz reg_dwi_t1 $subj_sess_prefix > /dev/null
    

    popd
   
    #combine into single html
    # copy over png files, and grep href, and make first/last line
    mkdir -p $derivatives/reports/images
    final_qc=$derivatives/reports/$subj_sess_prefix.html
    echo "<HTML><TITLE>$subj</TITLE><BODY BGCOLOR=\"#aaaaff\">" > $final_qc
    grep -h href $work_folder/QC/*/index.html >> $final_qc
    echo "</BODY></HTML>" >>$final_qc

    #move relative to images subfolder
    sed -i 's/href="/href="images\//' $final_qc
    sed -i 's/src="/src="images\//' $final_qc

    #move files and clean-up
    rm $work_folder/QC/*/grot*.png
    mv $work_folder/QC/*/*.png $derivatives/reports/images
    rm $work_folder/QC/*/*
    rmdir  $work_folder/QC/*
    rmdir $work_folder/QC

    done #subj-ses

    done #subj

    # we still need QC for:
    # processing performed
    # eddy stats
    # color rgb??
    # DWI overlaid with atlas labels??

#=====================================================================
#---------------------- END STAGE:  group ----------------------------
#=====================================================================


#=====================================================================
#--------------------- BEGIN STAGE:  participant2  -------------------
#=====================================================================

 elif [ "$analysis_level" = "participant2" ]
 then

 #network connectivity matrix
 echo --- Running stage participant2:  connectivity analysis ---


 if [ -e $work_folder/$atlas_space/labels/t1/$atlas_label_nii ]
 then
     atlas_label_nii=`realpath $work_folder/$atlas_space/labels/t1/$atlas_label_nii`
 else
     if [ ! -e $atlas_label_nii ]
     then
      echo "--atlas_label_nii $atlas_label_nii does not exist!"
      exit 1
    else
     atlas_label_nii=`realpath $atlas_label_nii`
     fi
 fi

 if [ -e $work_folder/$atlas_space/labels/t1/$atlas_label_csv ]
 then
     atlas_label_csv=`realpath $work_folder/$atlas_space/labels/t1/$atlas_label_csv`
 else
     if [ ! -e $atlas_label_csv ]
     then
      echo "--atlas_label_csv $atlas_label_csv does not exist!"
      exit 1
    else
     atlas_label_csv=`realpath $atlas_label_csv`
    fi

 fi

 pushd $work_folder
  for subj in $subjlist 
  do
      #add on sub- if not exists
      subj=`fixsubj $subj`

      #loop over sub- and sub-/ses-
    for subjfolder in `ls $in_bids/$subj/dwi $in_bids/$subj/ses-*/dwi`
    do

        subj_sess_dir=${subjfolder%/dwi}
        sess=${subj_sess_dir##*/}
        subj_sess_prefix=${subj}_${sess}


     #check if bedpost results exist
      if [ ! -e $derivatives/bedpost/$subj_sess_prefix/dyads1.nii.gz ]
      then
        echo "Bedpost processing in $derivatives/bedpost/$subj_sess_prefix not complete, skipping ..."
        continue
      fi

     echo $execpath/bin/processProbtrackConnectivity  $derivatives/bedpost probtrack.$atlas $nprobseeds $atlas_label_nii $atlas_label_csv $atlas_space $n_cpus $derivatives/prepdwi/$subj_sess_prefix/dwi/${subj_sess_prefix}_dwi_atlas-${atlas}_connectivity.csv $subj_sess_prefix
     $execpath/bin/processProbtrackConnectivity  $derivatives/bedpost probtrack.$atlas $nprobseeds $atlas_label_nii $atlas_label_csv $atlas_space $n_cpus $derivatives/prepdwi/$subj_sess_prefix/dwi/${subj_sess_prefix}_dwi_atlas-${atlas}_connectivity.csv $subj_sess_prefix

 done #subjsess
  done #subj


   popd

#=====================================================================
#------------------- END STAGE:  participant2 ------------------------
#=====================================================================



 else    
  echo "unknown analysis level: $analysis_level"
  
  exit 1
fi


