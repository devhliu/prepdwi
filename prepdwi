#!/bin/bash

function die {
 echo $1 >&2
 exit 1
}

matching_dwi=
participant_label=
notopup=0
dke=0
bedpost=1
matching_T1w=
n_cpus=8
reg_init_subj=

atlas_space=MNI152Nlin2009cAsym

if [ "$#" -lt 3 ]
then
 echo "Usage: prepdwi bids_dir output_dir {participant,group} <optional arguments>"
 echo "          [--participant_label PARTICIPANT_LABEL [PARTICIPANT_LABEL...]]"
 echo "          [--matching_dwi MATCHING_PATTERN"
 echo "          [--matching_T1w MATCHING_STRING"
 echo "          [--reg_init_participant PARTICIPANT_LABEL"
 echo "          [--atlas_label_nii NIFTI" 
 echo "          [--atlas_label_csv LABEL_INDEX_CSV"
 echo "          [--no-topup]"
 echo "          [--no-bedpost]"
 echo "          [--dke]"
 echo "          [--n_cpus] NCPUS (for bedpost, default: 8) "
 echo ""
 exit 1
fi


in_bids=$1 
out_folder=$2 
analysis_level=$3


shift 3



while :; do
      case $1 in
     -h|-\?|--help)
	     usage
            exit
              ;;
     --no-topup )
	notopup=1;;
     --no-bedpost )
	bedpost=0;;
     --dke )
	dke=1;;
     --n_cpus )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                n_cpus=$2
                  shift
	      else
              die 'error: "--n_cpus" requires a non-empty option argument.'
            fi
              ;;

     --participant_label )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                participant_label=$2
                  shift
	      else
              die 'error: "--participant" requires a non-empty option argument.'
            fi
              ;;
     --participant_label=?*)
          participant_label=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --participant_label=)         # handle the case of an empty --participant=
         die 'error: "--participant_label" requires a non-empty option argument.'
          ;;
     --matching_dwi )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matching_dwi=$2
                  shift
	      else
              die 'error: "--matching_dwi" requires a non-empty option argument.'
            fi
              ;;
     --matching_dwi=?*)
          matching_dwi=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matching_dwi=)         # handle the case of an empty --acq=
         die 'error: "--matching_dwi" requires a non-empty option argument.'
          ;;
     --matching_T1w )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                matching_T1w=$2
                  shift
	      else
              die 'error: "--matching_T1w" requires a non-empty option argument.'
            fi
              ;;
     --matching_T1w=?*)
          matching_T1w=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --matching_T1w=)         # handle the case of an empty --acq=
         die 'error: "--matching_dwi" requires a non-empty option argument.'
          ;;
      --reg_init_participant )       # takes an option argument; ensure it has been specified.
          if [ "$2" ]; then
                reg_init_subj=$2
                  shift
	      else
              die 'error: "--reg_init_participant" requires a non-empty option argument.'
            fi
              ;;
     --reg_init_participant=?*)
          reg_init_subj=${1#*=} # delete everything up to "=" and assign the remainder.
            ;;
          --reg_init_participant=)         # handle the case of an empty --participant=
         die 'error: "--reg_init_participant" requires a non-empty option argument.'
          ;;

      




      -?*)
            printf 'WARN: Unknown option (ignored): %s\n' "$1" >&2
              ;;
     *)               # Default case: No more options, so break out of the loop.
          break
    esac
  
 shift
  done


shift $((OPTIND-1))


echo matching_dwi=$matching_dwi
echo participant_label=$participant_label

if [ -e $in_bids ]
then
	in_bids=`realpath $in_bids`
else
	echo "ERROR: bids_dir $in_bids does not exist!"
	exit 1
fi


dwi_prefix=uncorrected

participants=$in_bids/participants.tsv

work_folder=$out_folder/work
derivatives=$out_folder #bids derivatives

mkdir -p $work_folder $derivatives


if [ -n "$participant_label" ]
then
subjlist=`echo $participant_label | sed  's/,/\ /g'` 
else
subjlist=`tail -n +2 $participants | awk '{print $1}'`
fi



if [ "$analysis_level" = "participant" ]
then
 echo " running participant level analysis"


pushd $work_folder
echo $participants

if [ -n "$matching_dwi" ]
then
  searchstring_dwi=\*${matching_dwi}\*dwi.nii*
else
  searchstring_dwi=*dwi.nii*
fi

if [ -n "$matching_T1w" ]
then
  searchstring_t1w=\*${matching_T1w}\*T1w.nii*
else
  searchstring_t1w=*T1w.nii*
fi

for subj in $subjlist 
do

#add on sub- if not exists
if [ ! "${subj:0:4}" = "sub-" ]
then
  subj="sub-$subj"
fi


N_t1w=`eval ls $in_bids/$subj/anat/${subj}${searchstring_t1w} | wc -l`
in_t1w=`eval ls $in_bids/$subj/anat/${subj}${searchstring_t1w} | head -n 1`

echo Found $N_t1w matching T1w, using first found: $in_t1w
if [ ! -e $subj/t1/t1.nii.gz ]
then
echo importT1 $in_t1w $subj
importT1 $in_t1w $subj
fi

if [ ! -e $subj/t1/t1.brain.inorm.nii.gz ]
then
preprocT1 $subj
fi
 
Ndwi=`eval ls $in_bids/$subj/dwi/${subj}${searchstring_dwi} | wc -l`

 if [ ! -e $subj/dwi/uncorrected/dwi_$Ndwi.nii.gz ]
 then

 echo Ndwi=$Ndwi
echo Found $Ndwi matching dwi, using all: 
 eval ls $in_bids/$subj/dwi/${subj}${searchstring_dwi}

 echo "importDWI ${dwi_prefix} $Ndwi `eval ls $in_bids/$subj/dwi/${subj}${searchstring_dwi}` $subj"
 importDWI ${dwi_prefix} $Ndwi `eval ls $in_bids/$subj/dwi/${subj}${searchstring_dwi}` $subj

 fi

 if [ ! -e $subj/dwi/uncorrected_denoise/dwi_$Ndwi.nii.gz ]
 then
 echo processDwiDenoise uncorrected $subj
 processDwiDenoise uncorrected $subj
 fi

 if [ ! -e $subj/dwi/uncorrected_denoise_unring/dwi_$Ndwi.nii.gz ]
 then
 echo processUnring uncorrected_denoise $subj
 processUnring uncorrected_denoise $subj
 fi


 if [ "$notopup" = 1 -o "$Ndwi" = "1" ] 
 then
 
  if [ ! -e $subj/dwi/uncorrected_denoise_unring_eddy/dwi.nii.gz ]
  then
   echo processEddyNoTopUp uncorrected_denoise_unring $subj
   processEddyNoTopUp uncorrected_denoise_unring $subj
  fi
  
   eddy=eddy
 else

  if [ ! -e $subj/dwi/uncorrected_denoise_unring_topup/dwi.nii.gz ]
  then 
    echo processTopUp uncorrected_denoise_unring $subj
    processTopUp uncorrected_denoise_unring $subj
  fi

  if [ ! -e $subj/dwi/uncorrected_denoise_unring_topup_eddy/dwi.nii.gz ]
  then
    echo processEddy uncorrected_denoise_unring_topup $subj
    processEddy uncorrected_denoise_unring_topup $subj
  fi
  eddy=topup_eddy
 fi

  if [ ! -e $subj/dwi/uncorrected_denoise_unring_${eddy}_regT1/dwi.nii.gz ]
  then
  echo processRegT1 uncorrected_denoise_unring_$eddy $subj
  processRegT1 uncorrected_denoise_unring_$eddy $subj
  fi

  
  #continue running pipelines
  if [ "$bedpost" = 1 ]
  then 
    if [ ! -e $subj/dwi/uncorrected_denoise_unring_${eddy}_regT1/bedpost.bedpostX/dyads1.nii.gz ]
    then
    echo processBedpost $n_cpus uncorrected_denoise_unring_${eddy}_regT1 $subj
    processBedpost $n_cpus uncorrected_denoise_unring_${eddy}_regT1 $subj
    fi
  fi 

  if [ "$dke" = 1 ]
  then 
    if [ ! -e $subj/dwi/uncorrected_denoise_unring_${eddy}_regT1_dke/kmean.nii.gz ]
    then
    echo processDKE uncorrected_denoise_unring_${eddy}_regT1 $subj
    processDKE uncorrected_denoise_unring_${eddy}_regT1 $subj
    fi
  fi 

 
  processCleanupBIDS uncorrected_denoise_unring_${eddy}_regT1 $derivatives $subj

done


popd


 elif [ "$analysis_level" = "participant2" ]
 then


     ## move this to basic participant level analysis later..

   echo "participant2 level"
   #perform MNI registration with T1w

 pushd $work_folder

   echo in_atlas_dir: $in_atlas_dir
#copy atlases to output folder
for atlas in `ls -d $in_atlas_dir/*`
do
 atlas_name=${atlas##*/}

 #if atlas not copied, then:
 if [ ! -e $atlas_name ]
 then
 #mkdir to ensure only one process copies the files..
 if $(mkdir $atlas_name)
 then
   cp -Rv $atlas/* $atlas_name
 else
   sleep 30
 fi
 fi

   if [ -n "$reg_init_subj" ]
   then
    reg_intersubj_aladin  t1 $atlas_name $subj -i $reg_init_subj
    else
   reg_intersubj_aladin  t1 $atlas_name $subj 
   fi

   reg_bspline_f3d t1 $atlas_name $subj

 for label in `ls -d $atlas_name/labels/t1/*`
 do
   label_name=${label##*/}
    
   propLabels_reg_bspline_f3d t1 $label_name $atlas_name $subj
 done #label

done #atlas
popd


elif [ "$analysis_level" = "group1" ]
 then

    echo "generate preproc QC reports"

    #need to make a subjlist for this command 
    mkdir -p $work_folder/etc
    qclist=$work_folder/etc/subjects
    rm -f $qclist
    touch $qclist
    for subj in $subjlist
    do
        subj=`fixsubj $subj`
        echo $subj >> $qclist
    done
    
    pushd $work_dir
    genOverlay_brainmask $qclist

    for atlas in `ls -d $in_atlas_dir/*`
    do
     atlas_name=${atlas##*/}
     genOverlay_affine_atlasReg $atlas_name $qclist
     genOverlay_bspline_atlasReg $atlas_name $qclist
    done

popd

    # we need QC for:

    # brainmask
    # T1 / MNI affine reg
    # T1 / MNI nlin reg
    # T1 / DWI rigid reg
    # eddy stats
    # color rgb??
    # DWI overlaid with atlas labels??

 elif [ "$analysis_level" = "participant3" ]
 then


   #network connectivity
   echo "participant3 level"

   #required options:

   #import atlas_label_nii file  -> imports to labelgroup "imported"
     #or:  
   #existing label-group and nii filename
  
   mkdir -p $work_folder/$atlas_space/labels/t1/imported
   cp -v $atlas_label_nii $work_folder/$atlas_space/labels/t1/imported
   propLabels_reg_bspline_f3d t1 imported $atlas_space $subj


   #atlas_label_csv

   #need to loop through csv, extract labels, add to targets.txt file
   #run probtractx with network mode 


   #save to: 
   #   bedpost/sub-XXX/probtrack.$atlas_name.$label_csv_name

 else    
  echo "unknown analysis level: $analysis_level"
  

  exit 0
fi


